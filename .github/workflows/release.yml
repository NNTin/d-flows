name: Release Workflow

on:
  workflow_dispatch:
    inputs:
      version:
        type: string
        required: true
        description: Semantic version (e.g., "1.0.0", "2.1.3")
      target_branch:
        description: 'Branch to release version on (main default, release/vX for older majors, or type custom branch name)'
        required: true
        type: string
        default: main

permissions:
  contents: write

concurrency:
  group: release-workflow
  cancel-in-progress: false

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      MAJOR_VERSION: ${{ steps.extract-major-version.outputs.MAJOR_VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0
          fetch-tags: false  # Disabled to prevent remote tag fetching during act tests
          token: ${{ secrets.GITHUB_TOKEN != '' && secrets.GITHUB_TOKEN || env.GITHUB_TOKEN != '' && env.GITHUB_TOKEN || env.TOKEN_FALLBACK }}

      # Restore commit objects from bundle before restoring tags. This ensures all commit
      # SHAs referenced by tags exist in the repository. The bundle is created by
      # Setup-TestScenario.ps1 during test setup.
      - name: Restore test commits when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          echo "ðŸ“¦ Running under act - checking for test commits bundle"
          
          echo "ðŸ“‹ Git log BEFORE unbundle:"
          git log --oneline -n 5 || echo "No commits"
          
          BUNDLE_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-commits.bundle"
          
          # Fallback: if test-commits.bundle doesn't exist, try to find timestamped bundle
          if [[ ! -f "$BUNDLE_FILE" ]]; then
            echo "âš ï¸ test-commits.bundle not found, checking for timestamped bundles..."
            TIMESTAMPED_BUNDLE=$(ls -t "${TEST_STATE_PATH:-/tmp/test-state}"/commits-*.bundle 2>/dev/null | head -n 1 || echo "")
            if [[ -n "$TIMESTAMPED_BUNDLE" && -f "$TIMESTAMPED_BUNDLE" ]]; then
              BUNDLE_FILE="$TIMESTAMPED_BUNDLE"
              echo "ðŸ“¦ Found timestamped bundle: $BUNDLE_FILE"
            fi
          fi
          
          if [[ -f "$BUNDLE_FILE" ]]; then
            echo "ðŸ“¦ Found test commits bundle: $BUNDLE_FILE"
            
            # Check if bundle file is empty (created for empty repositories)
            if [[ ! -s "$BUNDLE_FILE" ]]; then
              echo "âš ï¸ Bundle file is empty (no commits to restore)"
            else
              echo "ðŸ” Verifying bundle integrity..."
              if git bundle verify "$BUNDLE_FILE" 2>&1; then
                echo "âœ… Bundle verification passed"
              else
                echo "âš ï¸ Bundle verification failed, attempting unbundle anyway"
              fi
              
              echo "ðŸ“¦ Unbundling commits..."
              UNBUNDLE_OUTPUT=$(git bundle unbundle "$BUNDLE_FILE" 2>&1 || true)
              echo "$UNBUNDLE_OUTPUT"
              
              # Count refs unbundled
              REF_COUNT=$(echo "$UNBUNDLE_OUTPUT" | grep -c '^\s*[a-f0-9]\{40\}\s' || echo "0")
              echo "âœ… Test commits restored from bundle ($REF_COUNT refs unbundled)"
            fi
          else
            echo "âš ï¸ No test commits bundle found at ${TEST_STATE_PATH:-/tmp/test-state}/test-commits.bundle"
            echo "âš ï¸ No timestamped commits-*.bundle files found"
            echo "âœ… Clean state - no commits bundle (correct for first release or scenarios without commits)"
          fi
          
          echo "ðŸ“‹ Git log AFTER unbundle:"
          git log --oneline -n 5 || echo "No commits"

      - name: Setup test tags when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          # When running under act, restore test tags from metadata file
          echo "Running under act - restoring test tags"
          
          echo "ðŸ“‹ Git tags BEFORE cleanup:"
          git tag -l || echo "No tags"
          
          # Delete all existing tags to ensure clean state
          echo "ðŸ§¹ Cleaning all existing tags..."
          git tag -l | xargs -r git tag -d 2>/dev/null || true
          
          echo "ðŸ“‹ Git tags AFTER cleanup:"
          git tag -l || echo "No tags"
          
          TAG_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-tags.txt"
          if [[ -f "$TAG_FILE" ]]; then
            echo "ðŸ“‹ Found test tags file: $TAG_FILE"
            echo "ðŸ“‹ Contents of test-tags.txt:"
            cat "$TAG_FILE"
            echo "---"
            
            while IFS=' ' read -r tag_name commit_sha; do
              if [[ -n "$tag_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                echo "Creating test tag: $tag_name at $commit_sha"
                git tag "$tag_name" "$commit_sha" 2>/dev/null || echo "Tag $tag_name already exists"
              fi
            done < "$TAG_FILE"
            echo "âœ… Test tags restored from file"
          else
            echo "âš ï¸ No test tags file found at $TAG_FILE"
            echo "âœ… Clean state - no tags (correct for first release)"
          fi
          
          echo "ðŸ“‹ Git tags FINAL:"
          git tag -l || echo "No tags"

      - name: Setup test branches when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          echo "ðŸŒ³ Running under act - restoring test branches"
          
          echo "ðŸ“‹ Git branches BEFORE cleanup:"
          git branch -a || echo "No branches"
          
          echo "ðŸ§¹ Cleaning all existing local branches..."
          git branch | grep -v "^\*" | xargs -r git branch -D 2>/dev/null || true
          
          echo "ðŸ“‹ Git branches AFTER cleanup:"
          git branch -a || echo "No branches"
          
          BRANCH_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-branches.txt"
          
          if [[ -f "$BRANCH_FILE" ]]; then
            echo "ðŸ“‹ Found test branches file: $BRANCH_FILE"
            echo "ðŸ“‹ Contents of test-branches.txt:"
            cat "$BRANCH_FILE"
            echo "---"
            
            # Get current branch before loop
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

            while IFS=' ' read -r branch_name commit_sha; do
              if [[ -n "$branch_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                
                # Skip the currently checked out branch (will handle it separately)
                if [[ "$branch_name" == "$CURRENT_BRANCH" ]]; then
                  echo "Skipping currently checked out branch: $branch_name (will update after detaching)"
                  continue
                fi
                
                echo "Creating test branch: $branch_name at $commit_sha"
                git branch -f "$branch_name" "$commit_sha" 2>/dev/null || echo "Failed to create branch $branch_name"
              fi
            done < "$BRANCH_FILE"
            echo "âœ… Test branches restored from file"
          else
            echo "âš ï¸ No test branches file found at $BRANCH_FILE"
            echo "âœ… Clean state - no branches (correct for first release)"
          fi
          
          # Checkout the target branch to position HEAD at the test commit
          TARGET_BRANCH="${{ inputs.target_branch }}"
          TARGET_COMMIT_SHA=""  # Initialize variable to store target branch's commit

          echo "ðŸ” Current HEAD position:"
          CURRENT_HEAD=$(git rev-parse HEAD)
          echo "  Commit: $CURRENT_HEAD"

          # Read the branches file to find the target branch's commit SHA
          if [[ -f "$BRANCH_FILE" ]]; then
            while IFS=' ' read -r branch_name commit_sha; do
              if [[ -n "$branch_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                
                # Capture the commit SHA for the target branch
                if [[ "$branch_name" == "$TARGET_BRANCH" ]]; then
                  TARGET_COMMIT_SHA="$commit_sha"
                  echo "ðŸ“ Found target branch '$TARGET_BRANCH' should point to: $TARGET_COMMIT_SHA"
                fi
              fi
            done < "$BRANCH_FILE"
          fi

          # Verify the target branch exists and we have its commit SHA
          if git show-ref --verify "refs/heads/$TARGET_BRANCH" > /dev/null 2>&1; then
            if [[ -n "$TARGET_COMMIT_SHA" ]]; then
              echo "ðŸ”„ Repositioning branch '$TARGET_BRANCH' to test commit: $TARGET_COMMIT_SHA"
              
              # Detach HEAD first to avoid worktree conflict
              git checkout --detach
              
              # Force-update the branch to point to the test commit
              git branch -f "$TARGET_BRANCH" "$TARGET_COMMIT_SHA"
              
              # Checkout the updated branch
              git checkout "$TARGET_BRANCH"
              
              NEW_HEAD=$(git rev-parse HEAD)
              echo "âœ… HEAD now at: $NEW_HEAD"
              
              # Verify we're at the correct commit
              if [[ "$NEW_HEAD" == "$TARGET_COMMIT_SHA" ]]; then
                echo "âœ… Branch checkout successful - at test commit"
              else
                echo "âš ï¸ Warning: HEAD ($NEW_HEAD) doesn't match expected commit ($TARGET_COMMIT_SHA)"
              fi
            else
              echo "âš ï¸ Target branch $TARGET_BRANCH exists but commit SHA not found in test-branches.txt"
              echo "   Skipping checkout"
            fi
          else
            echo "âš ï¸ Target branch $TARGET_BRANCH not found in test branches"
            echo "   (This is expected for scenarios without the target branch)"
          fi
          
          echo "ðŸ“‹ Git branches FINAL:"
          git branch -a || echo "No branches"

      - name: Validate version format
        shell: bash
        run: |
          if [[ ! "${{ inputs.version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must be in semantic versioning format (e.g., 1.0.0, 2.1.3)" >&2
            exit 1
          fi

      - name: Check for existing tag
        shell: bash
        run: |
          if git tag -l "v${{ inputs.version }}" | grep -q "v${{ inputs.version }}"; then
            echo "Error: Tag v${{ inputs.version }} already exists" >&2
            exit 1
          fi

      - name: Create release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "github-actions[bot]@users.noreply.github.com"
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          if [[ -n "$ACT" ]]; then        
            VERSION="v${{ inputs.version }}"
            git tag -a "$VERSION" -f -m "Release $VERSION"
          else
            gh release create "v${{ inputs.version }}" \
              --generate-notes \
              --title "Release v${{ inputs.version }}" \
              --target "${{ inputs.target_branch }}"
          fi

      - name: Extract major version
        id: extract-major-version
        shell: bash
        run: |
          MAJOR_VERSION=$(echo "${{ inputs.version }}" | cut -d. -f1)
          
          if [[ -z "$MAJOR_VERSION" ]]; then
            echo "Error: Failed to extract major version from ${{ inputs.version }}" >&2
            exit 1
          fi
          
          echo "MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_ENV"
          echo "MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_OUTPUT"
          
          # Print distinctive markers for act (ACT_TESTING_MODE)
          # Output to stdout and step summary to ensure visibility
          if [[ -n "$ACT" ]]; then
            echo "OUTPUT: MAJOR_VERSION=$MAJOR_VERSION"
            # Also write to step summary for act compatibility
            echo "OUTPUT: MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Create annotated major tag
        shell: bash
        env:
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "github-actions[bot]@users.noreply.github.com"
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          git tag -a "v$MAJOR_VERSION" -f -m "Update v$MAJOR_VERSION -> v${{ inputs.version }}"

      - name: Push major tag
        if: ${{ !env.ACT }} # only run if NOT running under act
        shell: bash
        run: |
          git push origin "v$MAJOR_VERSION"

      - name: Update step summary with major tag information
        shell: bash
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          ## Release Summary
          - âœ… Release created: v${{ inputs.version }}
          - ðŸ·ï¸ Major tag v$MAJOR_VERSION updated to point to v${{ inputs.version }}
          - ðŸ”— [View Release](${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ inputs.version }})
          - ðŸ”— [View Tags](${{ github.server_url }}/${{ github.repository }}/tags)
          EOF
          
          echo "Release created: ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ inputs.version }}"
          echo "Major tag v$MAJOR_VERSION updated to point to v${{ inputs.version }}"