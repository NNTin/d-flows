name: Release Workflow

on:
  workflow_dispatch:
    inputs:
      version:
        type: string
        required: true
        description: Semantic version (e.g., "1.0.0", "2.1.3")
      target_branch:
        description: 'Branch to release version on (main default, release/vX for older majors, or type custom branch name)'
        required: true
        type: string
        default: main

permissions:
  contents: write

concurrency:
  group: release-workflow
  cancel-in-progress: false

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      MAJOR_VERSION: ${{ steps.extract-major-version.outputs.MAJOR_VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0
          fetch-tags: false  # Disabled to prevent remote tag fetching during act tests
          token: ${{ secrets.GITHUB_TOKEN != '' && secrets.GITHUB_TOKEN || env.GITHUB_TOKEN != '' && env.GITHUB_TOKEN || env.TOKEN_FALLBACK }}

      - name: Setup test tags when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          # When running under act, restore test tags from metadata file
          echo "Running under act - restoring test tags"
          
          echo "ðŸ“‹ Git tags BEFORE cleanup:"
          git tag -l || echo "No tags"
          
          # Delete all existing tags to ensure clean state
          echo "ðŸ§¹ Cleaning all existing tags..."
          git tag -l | xargs -r git tag -d 2>/dev/null || true
          
          echo "ðŸ“‹ Git tags AFTER cleanup:"
          git tag -l || echo "No tags"
          
          TAG_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-tags.txt"
          if [[ -f "$TAG_FILE" ]]; then
            echo "ðŸ“‹ Found test tags file: $TAG_FILE"
            echo "ðŸ“‹ Contents of test-tags.txt:"
            cat "$TAG_FILE"
            echo "---"
            
            while IFS=' ' read -r tag_name commit_sha; do
              if [[ -n "$tag_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                echo "Creating test tag: $tag_name at $commit_sha"
                git tag "$tag_name" "$commit_sha" 2>/dev/null || echo "Tag $tag_name already exists"
              fi
            done < "$TAG_FILE"
            echo "âœ… Test tags restored from file"
          else
            echo "âš ï¸ No test tags file found at $TAG_FILE"
            echo "âœ… Clean state - no tags (correct for first release)"
          fi
          
          echo "ðŸ“‹ Git tags FINAL:"
          git tag -l || echo "No tags"

      - name: Setup test branches when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          echo "ðŸŒ³ Running under act - restoring test branches"
          
          echo "ðŸ“‹ Git branches BEFORE cleanup:"
          git branch -a || echo "No branches"
          
          echo "ðŸ§¹ Cleaning all existing local branches..."
          git branch | grep -v "^\*" | xargs -r git branch -D 2>/dev/null || true
          
          echo "ðŸ“‹ Git branches AFTER cleanup:"
          git branch -a || echo "No branches"
          
          BRANCH_FILE="${{ env.TEST_STATE_PATH }}test-branches.txt"
          
          if [[ -f "$BRANCH_FILE" ]]; then
            echo "ðŸ“‹ Found test branches file: $BRANCH_FILE"
            echo "ðŸ“‹ Contents of test-branches.txt:"
            cat "$BRANCH_FILE"
            echo "---"
            
            while IFS=' ' read -r branch_name commit_sha; do
              if [[ -n "$branch_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                echo "Creating test branch: $branch_name at $commit_sha"
                git branch "$branch_name" "$commit_sha" 2>/dev/null || echo "Branch $branch_name already exists or failed to create"
              fi
            done < "$BRANCH_FILE"
            echo "âœ… Test branches restored from file"
          else
            echo "âš ï¸ No test branches file found at $BRANCH_FILE"
            echo "âœ… Clean state - no branches (correct for first release)"
          fi
          
          echo "ðŸ“‹ Git branches FINAL:"
          git branch -a || echo "No branches"

      - name: Validate version format
        shell: bash
        run: |
          if [[ ! "${{ inputs.version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Error: Version must be in semantic versioning format (e.g., 1.0.0, 2.1.3)" >&2
            exit 1
          fi

      - name: Check for existing tag
        shell: bash
        run: |
          if git tag -l "v${{ inputs.version }}" | grep -q "v${{ inputs.version }}"; then
            echo "Error: Tag v${{ inputs.version }} already exists" >&2
            exit 1
          fi

      - name: Create release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "github-actions[bot]@users.noreply.github.com"
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          if [[ -n "$ACT" ]]; then        
            VERSION="v${{ inputs.version }}"
            git tag -a "$VERSION" -f -m "Release $VERSION"
          else
            gh release create "v${{ inputs.version }}" \
              --generate-notes \
              --title "Release v${{ inputs.version }}" \
              --target "${{ inputs.target_branch }}"
          fi

      - name: Extract major version
        id: extract-major-version
        shell: bash
        run: |
          MAJOR_VERSION=$(echo "${{ inputs.version }}" | cut -d. -f1)
          
          if [[ -z "$MAJOR_VERSION" ]]; then
            echo "Error: Failed to extract major version from ${{ inputs.version }}" >&2
            exit 1
          fi
          
          echo "MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_ENV"
          echo "MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_OUTPUT"
          
          # Print distinctive markers for act (ACT_TESTING_MODE)
          # Output to stdout and step summary to ensure visibility
          if [[ -n "$ACT" ]]; then
            echo "OUTPUT: MAJOR_VERSION=$MAJOR_VERSION"
            # Also write to step summary for act compatibility
            echo "OUTPUT: MAJOR_VERSION=$MAJOR_VERSION" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Create annotated major tag
        shell: bash
        env:
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "github-actions[bot]@users.noreply.github.com"
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "github-actions[bot]@users.noreply.github.com"
        run: |
          git tag -a "v$MAJOR_VERSION" -f -m "Update v$MAJOR_VERSION -> v${{ inputs.version }}"

      - name: Push major tag
        if: ${{ !env.ACT }} # only run if NOT running under act
        shell: bash
        run: |
          git push origin "v$MAJOR_VERSION"

      - name: Update step summary with major tag information
        shell: bash
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          ## Release Summary
          - âœ… Release created: v${{ inputs.version }}
          - ðŸ·ï¸ Major tag v$MAJOR_VERSION updated to point to v${{ inputs.version }}
          - ðŸ”— [View Release](${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ inputs.version }})
          - ðŸ”— [View Tags](${{ github.server_url }}/${{ github.repository }}/tags)
          EOF
          
          echo "Release created: ${{ github.server_url }}/${{ github.repository }}/releases/tag/v${{ inputs.version }}"
          echo "Major tag v$MAJOR_VERSION updated to point to v${{ inputs.version }}"