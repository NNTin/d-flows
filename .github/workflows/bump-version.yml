name: Bump Version

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Type of version bump to perform'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
      target_branch:
        description: 'Branch to bump version on (main for latest major, release/vX for older majors, or type custom branch name)'
        required: true
        type: string
        default: main

permissions:
  contents: write
  actions: write

concurrency:
  group: bump-version-${{ inputs.target_branch }}
  cancel-in-progress: false

jobs:
  calculate-and-release:
    runs-on: ubuntu-latest
    outputs:
      RELEASE_BRANCH_CREATED: ${{ steps.create-release-branch.outputs.RELEASE_BRANCH_CREATED }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0
          fetch-tags: false  # Disabled to prevent remote tag fetching during act tests
          token: ${{ secrets.GITHUB_TOKEN != '' && secrets.GITHUB_TOKEN || env.GITHUB_TOKEN != '' && env.GITHUB_TOKEN || env.TOKEN_FALLBACK }}

      # Restore commit objects from bundle before restoring tags. This ensures all commit
      # SHAs referenced by tags exist in the repository. The bundle is created by
      # Setup-TestScenario.ps1 during test setup.
      - name: Restore test commits when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          echo "ðŸ“¦ Running under act - checking for test commits bundle"
          
          echo "ðŸ“‹ Git log BEFORE unbundle:"
          git log --oneline -n 5 || echo "No commits"
          
          BUNDLE_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-commits.bundle"
          
          # Fallback: if test-commits.bundle doesn't exist, try to find timestamped bundle
          if [[ ! -f "$BUNDLE_FILE" ]]; then
            echo "âš ï¸ test-commits.bundle not found, checking for timestamped bundles..."
            TIMESTAMPED_BUNDLE=$(ls -t "${TEST_STATE_PATH:-/tmp/test-state}"/commits-*.bundle 2>/dev/null | head -n 1 || echo "")
            if [[ -n "$TIMESTAMPED_BUNDLE" && -f "$TIMESTAMPED_BUNDLE" ]]; then
              BUNDLE_FILE="$TIMESTAMPED_BUNDLE"
              echo "ðŸ“¦ Found timestamped bundle: $BUNDLE_FILE"
            fi
          fi
          
          if [[ -f "$BUNDLE_FILE" ]]; then
            echo "ðŸ“¦ Found test commits bundle: $BUNDLE_FILE"
            
            # Check if bundle file is empty (created for empty repositories)
            if [[ ! -s "$BUNDLE_FILE" ]]; then
              echo "âš ï¸ Bundle file is empty (no commits to restore)"
            else
              echo "ðŸ” Verifying bundle integrity..."
              if git bundle verify "$BUNDLE_FILE" 2>&1; then
                echo "âœ… Bundle verification passed"
              else
                echo "âš ï¸ Bundle verification failed, attempting unbundle anyway"
              fi
              
              echo "ðŸ“¦ Unbundling commits..."
              UNBUNDLE_OUTPUT=$(git bundle unbundle "$BUNDLE_FILE" 2>&1 || true)
              echo "$UNBUNDLE_OUTPUT"
              
              # Count refs unbundled
              REF_COUNT=$(echo "$UNBUNDLE_OUTPUT" | grep -c '^\s*[a-f0-9]\{40\}\s' || echo "0")
              echo "âœ… Test commits restored from bundle ($REF_COUNT refs unbundled)"
            fi
          else
            echo "âš ï¸ No test commits bundle found at ${TEST_STATE_PATH:-/tmp/test-state}/test-commits.bundle"
            echo "âš ï¸ No timestamped commits-*.bundle files found"
            echo "âœ… Clean state - no commits bundle (correct for first release or scenarios without commits)"
          fi
          
          echo "ðŸ“‹ Git log AFTER unbundle:"
          git log --oneline -n 5 || echo "No commits"

      - name: Setup test tags when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          # When running under act, restore test tags from metadata file
          echo "Running under act - restoring test tags"
          
          echo "ðŸ“‹ Git tags BEFORE cleanup:"
          git tag -l || echo "No tags"
          
          # Delete all existing tags to ensure clean state
          echo "ðŸ§¹ Cleaning all existing tags..."
          git tag -l | xargs -r git tag -d 2>/dev/null || true
          
          echo "ðŸ“‹ Git tags AFTER cleanup:"
          git tag -l || echo "No tags"
          
          TAG_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-tags.txt"
          if [[ -f "$TAG_FILE" ]]; then
            echo "ðŸ“‹ Found test tags file: $TAG_FILE"
            echo "ðŸ“‹ Contents of test-tags.txt:"
            cat "$TAG_FILE"
            echo "---"
            
            while IFS=' ' read -r tag_name commit_sha; do
              if [[ -n "$tag_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                echo "Creating test tag: $tag_name at $commit_sha"
                git tag "$tag_name" "$commit_sha" 2>/dev/null || echo "Tag $tag_name already exists"
              fi
            done < "$TAG_FILE"
            echo "âœ… Test tags restored from file"
          else
            echo "âš ï¸ No test tags file found at $TAG_FILE"
            echo "âœ… Clean state - no tags (correct for first release)"
          fi
          
          echo "ðŸ“‹ Git tags FINAL:"
          git tag -l || echo "No tags"

      - name: Setup test branches when running under act
        if: ${{ env.ACT }}
        shell: bash
        run: |
          echo "ðŸŒ³ Running under act - restoring test branches"
          
          echo "ðŸ“‹ Git branches BEFORE cleanup:"
          git branch -a || echo "No branches"
          
          echo "ðŸ§¹ Cleaning all existing local branches..."
          git branch | grep -v "^\*" | xargs -r git branch -D 2>/dev/null || true
          
          echo "ðŸ“‹ Git branches AFTER cleanup:"
          git branch -a || echo "No branches"
          
          BRANCH_FILE="${TEST_STATE_PATH:-/tmp/test-state}/test-branches.txt"
          
          if [[ -f "$BRANCH_FILE" ]]; then
            echo "ðŸ“‹ Found test branches file: $BRANCH_FILE"
            echo "ðŸ“‹ Contents of test-branches.txt:"
            cat "$BRANCH_FILE"
            echo "---"
            
            # Get current branch before loop
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

            while IFS=' ' read -r branch_name commit_sha; do
              if [[ -n "$branch_name" ]] && [[ -n "$commit_sha" ]]; then
                commit_sha=$(echo "$commit_sha" | tr -d '\r')
                
                # Skip the currently checked out branch (will handle it separately)
                if [[ "$branch_name" == "$CURRENT_BRANCH" ]]; then
                  echo "Skipping currently checked out branch: $branch_name (will update after detaching)"
                  continue
                fi
                
                echo "Creating test branch: $branch_name at $commit_sha"
                git branch -f "$branch_name" "$commit_sha" 2>/dev/null || echo "Failed to create branch $branch_name"
              fi
            done < "$BRANCH_FILE"
            echo "âœ… Test branches restored from file"
          else
            echo "âš ï¸ No test branches file found at $BRANCH_FILE"
            echo "âœ… Clean state - no branches (correct for first release)"
          fi
          
          # Checkout the target branch to position HEAD at the test commit
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          echo "ðŸ” Current HEAD position:"
          CURRENT_HEAD=$(git rev-parse HEAD)
          echo "  Commit: $CURRENT_HEAD"
          
          # Verify the target branch exists
          if git show-ref --verify "refs/heads/$TARGET_BRANCH" > /dev/null 2>&1; then
            echo "ðŸ”„ Checking out test branch: $TARGET_BRANCH"
            # Detach HEAD first to avoid worktree conflict
            git checkout --detach

            # Checkout the branch (already created in the loop above)
            git checkout "$TARGET_BRANCH" --force
            
            NEW_HEAD=$(git rev-parse HEAD)
            echo "âœ… HEAD now at: $NEW_HEAD"
            echo "ðŸ”„ Branch checkout successful"
          else
            echo "âš ï¸ Target branch $TARGET_BRANCH not found in test branches"
            echo "   (This is expected for scenarios without the target branch)"
          fi
          
          echo "ðŸ“‹ Git branches FINAL:"
          git branch -a || echo "No branches"

      - name: Validate branch selection
        shell: bash
        run: |
          set -e
          set -o pipefail
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          echo "ðŸ” Validating branch selection: $TARGET_BRANCH" >> "$GITHUB_STEP_SUMMARY"
          
          # Check if branch exists locally (already fetched by checkout action)
          # Note: We can't use git ls-remote because it may not have network access
          # The checkout action has already fetched all branches, so we check locally
          if git show-ref --verify "refs/remotes/origin/$TARGET_BRANCH" > /dev/null 2>&1; then
            echo "âœ… Branch '$TARGET_BRANCH' exists" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Error: Branch '$TARGET_BRANCH' does not exist in the repository" >&2
            echo "âŒ **Error:** Branch '$TARGET_BRANCH' does not exist in the repository" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          
          # Detect highest major version from existing tags
          HIGHEST_MAJOR=$(git tag -l "v*.*.*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sed 's/^v//' | cut -d. -f1 | sort -n | tail -n1 || echo "")
          HIGHEST_MAJOR=${HIGHEST_MAJOR:-0}
          
          # Validate branch logic
          if [[ "$TARGET_BRANCH" == "main" ]]; then
            echo "âœ… Using main branch for latest major version (v$((HIGHEST_MAJOR + 1)).x.x or continuation)" >> "$GITHUB_STEP_SUMMARY"
          elif [[ "$TARGET_BRANCH" =~ ^release/v([0-9]+)$ ]]; then
            BRANCH_MAJOR="${BASH_REMATCH[1]}"
            echo "âœ… Using release branch for major version v$BRANCH_MAJOR.x.x" >> "$GITHUB_STEP_SUMMARY"
            
            if [[ "$BRANCH_MAJOR" -gt "$HIGHEST_MAJOR" ]]; then
              echo "âš ï¸ Warning: Branch major version ($BRANCH_MAJOR) is higher than existing tags ($HIGHEST_MAJOR)" >> "$GITHUB_STEP_SUMMARY"
            fi
          else
            echo "âŒ Error: Invalid branch format. Use 'main' or 'release/vX'" >&2
            echo "âŒ **Error:** Invalid branch format. Use 'main' or 'release/vX'" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Fetch latest tag from selected branch
        shell: bash
        run: |
          set -e
          set -o pipefail
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          echo "ðŸ·ï¸ Fetching latest tag from branch: $TARGET_BRANCH" >> "$GITHUB_STEP_SUMMARY"
          
          # Get tags reachable from the current HEAD (checked out branch)
          LATEST_TAG=$(git tag --merged HEAD | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -n1 || echo "")
          
          if [[ -z "$LATEST_TAG" ]]; then
            echo "ðŸ“¦ No existing tags found - this will be the first release" >> "$GITHUB_STEP_SUMMARY"
            {
              echo "FIRST_RELEASE=true"
              echo "LATEST_TAG=$LATEST_TAG"
            } >> "$GITHUB_ENV"
          else
            echo "ðŸ“¦ Latest tag found: $LATEST_TAG" >> "$GITHUB_STEP_SUMMARY"
            {
              echo "FIRST_RELEASE=false"
              echo "LATEST_TAG=$LATEST_TAG"
            } >> "$GITHUB_ENV"
          fi

      - name: Parse current version
        shell: bash
        run: |
          set -e
          set -o pipefail
          
          if [[ "$FIRST_RELEASE" == "true" ]]; then
            echo "ðŸ†• First release - initializing version components" >> "$GITHUB_STEP_SUMMARY"
            MAJOR=0
            MINOR=0
            PATCH=0
          else
            # Extract version from tag (remove 'v' prefix)
            VERSION_STRING="${LATEST_TAG#v}"
            
            # Split into components
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_STRING"
            
            # Validate components are integers
            if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]] || ! [[ "$PATCH" =~ ^[0-9]+$ ]]; then
              echo "âŒ Error: Invalid version format in tag $LATEST_TAG" >&2
              echo "âŒ **Error:** Invalid version format in tag $LATEST_TAG" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
            
            echo "ðŸ“Š Current version components: $MAJOR.$MINOR.$PATCH" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          # Store components in environment
          {
            echo "CURRENT_MAJOR=$MAJOR"
            echo "CURRENT_MINOR=$MINOR"
            echo "CURRENT_PATCH=$PATCH"
          } >> "$GITHUB_ENV"

      - name: Calculate new version
        shell: bash
        run: |
          set -e
          set -o pipefail
          
          BUMP_TYPE="${{ inputs.bump_type }}"
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          if [[ "$FIRST_RELEASE" == "true" ]]; then
            # First release logic by branch
            if [[ "$TARGET_BRANCH" == "main" ]]; then
              # First release defaults to 0.1.0 for main
              NEW_MAJOR=0
              NEW_MINOR=1
              NEW_PATCH=0
              echo "ðŸŽ¯ First release version on main: 0.1.0" >> "$GITHUB_STEP_SUMMARY"
            elif [[ "$TARGET_BRANCH" =~ ^release/v([0-9]+)$ ]]; then
              echo "âŒ Error: First releases must start from main branch, not from release branches" >&2
              echo "âŒ **Error:** First releases must start from main branch, not from release branches" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            else
              echo "âŒ Error: Invalid target branch for first release" >&2
              echo "âŒ **Error:** Invalid target branch for first release" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
          else
            # Calculate based on bump type
            case "$BUMP_TYPE" in
              major)
                NEW_MAJOR=$((CURRENT_MAJOR + 1))
                NEW_MINOR=0
                NEW_PATCH=0
                ;;
              minor)
                NEW_MAJOR=$CURRENT_MAJOR
                NEW_MINOR=$((CURRENT_MINOR + 1))
                NEW_PATCH=0
                ;;
              patch)
                NEW_MAJOR=$CURRENT_MAJOR
                NEW_MINOR=$CURRENT_MINOR
                NEW_PATCH=$((CURRENT_PATCH + 1))
                ;;
              *)
                echo "âŒ Error: Invalid bump type '$BUMP_TYPE'" >&2
                echo "âŒ **Error:** Invalid bump type '$BUMP_TYPE'" >> "$GITHUB_STEP_SUMMARY"
                exit 1
                ;;
            esac
            
            echo "ðŸ”¼ $BUMP_TYPE bump: $CURRENT_MAJOR.$CURRENT_MINOR.$CURRENT_PATCH â†’ $NEW_MAJOR.$NEW_MINOR.$NEW_PATCH" >> "$GITHUB_STEP_SUMMARY"
          fi
          
          # Construct new version string
          NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          
          # Validate new version is greater than current (if not first release)
          if [[ "$FIRST_RELEASE" == "false" ]]; then
            CURRENT_VERSION="$CURRENT_MAJOR.$CURRENT_MINOR.$CURRENT_PATCH"
            if ! printf '%s\n%s\n' "$CURRENT_VERSION" "$NEW_VERSION" | sort -V -C; then
              echo "âŒ Error: New version $NEW_VERSION is not greater than current $CURRENT_VERSION" >&2
              echo "âŒ **Error:** New version $NEW_VERSION is not greater than current $CURRENT_VERSION" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
          fi
          
          # Store new version
          echo "NEW_VERSION=$NEW_VERSION" >> "$GITHUB_ENV"
          echo "NEW_VERSION=$NEW_VERSION" >> "$GITHUB_OUTPUT"
          
          # Print distinctive markers for act (ACT_TESTING_MODE)
          # Output to stdout and step summary to ensure visibility
          if [[ -n "$ACT" ]]; then
            echo "OUTPUT: NEW_VERSION=$NEW_VERSION"
            echo "OUTPUT: FIRST_RELEASE=$FIRST_RELEASE"
            echo "OUTPUT: CURRENT_MAJOR=$CURRENT_MAJOR"
            # Also write to step summary for act compatibility
            {
              echo "OUTPUT: NEW_VERSION=$NEW_VERSION"
              echo "OUTPUT: FIRST_RELEASE=$FIRST_RELEASE"
              echo "OUTPUT: CURRENT_MAJOR=$CURRENT_MAJOR"
            } >> "$GITHUB_STEP_SUMMARY"
          fi
          
          # Enforce main-branch semantics (bypass for first releases)
          if [[ "$TARGET_BRANCH" == "main" && "$FIRST_RELEASE" != "true" ]]; then
            # Determine highest major reachable from HEAD (main branch checked out)
            MAIN_HIGHEST_MAJOR=$(git tag --merged HEAD | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sed 's/^v//' | cut -d. -f1 | sort -n | tail -n1)
            MAIN_HIGHEST_MAJOR=${MAIN_HIGHEST_MAJOR:-0}
            
            NEW_MAJOR=$(echo "$NEW_VERSION" | cut -d. -f1)
            
            if [[ "$BUMP_TYPE" == "major" ]]; then
              # For major bump, allow NEW_VERSION major to be exactly highest_major+1
              EXPECTED_MAJOR=$((MAIN_HIGHEST_MAJOR + 1))
              if [[ "$NEW_MAJOR" != "$EXPECTED_MAJOR" ]]; then
                echo "âŒ Error: Major bump on main must create v$EXPECTED_MAJOR.x.x, but got v$NEW_VERSION" >&2
                echo "âŒ **Error:** Major bump on main must create v$EXPECTED_MAJOR.x.x, but got v$NEW_VERSION" >> "$GITHUB_STEP_SUMMARY"
                exit 1
              fi
            elif [[ "$BUMP_TYPE" == "minor" || "$BUMP_TYPE" == "patch" ]]; then
              # For minor/patch bump, require NEW_VERSION major to equal highest_major
              if [[ "$NEW_MAJOR" != "$MAIN_HIGHEST_MAJOR" ]]; then
                echo "âŒ Error: Minor/patch bump on main must stay within v$MAIN_HIGHEST_MAJOR.x.x, but got v$NEW_VERSION" >&2
                echo "âŒ **Error:** Minor/patch bump on main must stay within v$MAIN_HIGHEST_MAJOR.x.x, but got v$NEW_VERSION" >> "$GITHUB_STEP_SUMMARY"
                exit 1
              fi
            fi
            
            echo "âœ… Main branch semantics validated for $BUMP_TYPE bump" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Validate new version
        shell: bash
        run: |
          set -e
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          echo "âœ… Validating new version: v$NEW_VERSION" >> "$GITHUB_STEP_SUMMARY"
          
          # Check if tag already exists
          if git tag -l "v$NEW_VERSION" | grep -q "v$NEW_VERSION"; then
            echo "âŒ Error: Tag v$NEW_VERSION already exists" >&2
            echo "âŒ **Error:** Tag v$NEW_VERSION already exists" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          
          # Validate semantic versioning format
          if ! [[ "$NEW_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "âŒ Error: Version $NEW_VERSION does not follow semantic versioning format" >&2
            echo "âŒ **Error:** Version $NEW_VERSION does not follow semantic versioning format" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          
          # For release branches, validate major version matches
          if [[ "$TARGET_BRANCH" =~ ^release/v([0-9]+)$ ]]; then
            BRANCH_MAJOR="${BASH_REMATCH[1]}"
            VERSION_MAJOR=$(echo "$NEW_VERSION" | cut -d. -f1)
            
            if [[ "$VERSION_MAJOR" != "$BRANCH_MAJOR" ]]; then
              echo "âŒ Error: Major version mismatch - branch $TARGET_BRANCH should only create v$BRANCH_MAJOR.x.x versions, but got v$NEW_VERSION" >&2
              echo "âŒ **Error:** Major version mismatch - branch $TARGET_BRANCH should only create v$BRANCH_MAJOR.x.x versions, but got v$NEW_VERSION" >> "$GITHUB_STEP_SUMMARY"
              exit 1
            fi
          fi
          
          echo "âœ… Version validation passed" >> "$GITHUB_STEP_SUMMARY"

      - name: Display version bump summary
        shell: bash
        run: |
          set -e
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          BUMP_TYPE="${{ inputs.bump_type }}"
          
          # Compute current version display
          if [[ "$FIRST_RELEASE" == "true" ]]; then
            CURRENT_DISPLAY="None (First Release)"
          else
            CURRENT_DISPLAY="$LATEST_TAG"
          fi
          
          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          
          ## ðŸš€ Version Bump Summary
          
          | Field | Value |
          |-------|-------|
          | ðŸŒ¿ **Target Branch** | \`$TARGET_BRANCH\` |
          | ðŸ”¼ **Bump Type** | \`$BUMP_TYPE\` |
          | ðŸ“¦ **Current Version** | \`$CURRENT_DISPLAY\` |
          | ðŸŽ¯ **New Version** | \`v$NEW_VERSION\` |
          | ðŸ†• **First Release** | \`$FIRST_RELEASE\` |
          
          EOF

      - name: Create release branch for previous major version
        id: create-release-branch
        if: ${{ inputs.bump_type == 'major' && inputs.target_branch == 'main' && env.FIRST_RELEASE == 'false' }}
        shell: bash
        continue-on-error: false
        run: |
          set -e
          set -o pipefail
          
          # Add section header to step summary
          echo "## ðŸŒ¿ Release Branch Creation" >> "$GITHUB_STEP_SUMMARY"
          
          # Calculate previous major version
          PREVIOUS_MAJOR=$CURRENT_MAJOR
          
          # Find last tag of previous major
          LAST_TAG=$(git tag -l "v${PREVIOUS_MAJOR}.*.*" | grep -E "^v${PREVIOUS_MAJOR}\.[0-9]+\.[0-9]+$" | sort -V | tail -n1 || echo "")
          
          # Validate tag exists
          if [[ -z "$LAST_TAG" ]]; then
            echo "âŒ Error: No tags found for major version v${PREVIOUS_MAJOR}" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          
          # Get commit SHA
          COMMIT_SHA=$(git rev-list -n 1 "$LAST_TAG")
          SHORT_SHA=${COMMIT_SHA:0:7}
          
          # Check if branch already exists
          if git ls-remote --heads origin "release/v${PREVIOUS_MAJOR}" | grep -q "refs/heads/release/v${PREVIOUS_MAJOR}$"; then
            echo "âš ï¸ Release branch release/v${PREVIOUS_MAJOR} already exists, skipping creation" >> "$GITHUB_STEP_SUMMARY"
            echo "RELEASE_BRANCH_CREATED=false" >> "$GITHUB_OUTPUT"
            
            # Print ACT marker for test validation
            if [[ -n "$ACT" ]]; then
              echo "OUTPUT: RELEASE_BRANCH_CREATED=false"
              echo "OUTPUT: RELEASE_BRANCH_CREATED=false" >> "$GITHUB_STEP_SUMMARY"
            fi
            
            exit 0
          fi
          
          # Create local branch
          git branch "release/v${PREVIOUS_MAJOR}" "$COMMIT_SHA"
          
          # don't push when running under act
          if [[ -z "$ACT" ]]; then
            # Push to remote
            git push origin "release/v${PREVIOUS_MAJOR}"
          fi

          # Log success
          echo "âœ… Created release branch \`release/v${PREVIOUS_MAJOR}\` from tag ${LAST_TAG} at commit ${SHORT_SHA}" >> "$GITHUB_STEP_SUMMARY"
          echo "RELEASE_BRANCH_CREATED=true" >> "$GITHUB_OUTPUT"
          
          # Print ACT marker for test validation
          if [[ -n "$ACT" ]]; then
            echo "OUTPUT: RELEASE_BRANCH_CREATED=true"
            echo "OUTPUT: RELEASE_BRANCH_CREATED=true" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Trigger release workflow
        if: ${{ !env.ACT }} # only run if NOT running under act
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          
          echo "ðŸš€ Triggering release workflow for v$NEW_VERSION on $TARGET_BRANCH" >> "$GITHUB_STEP_SUMMARY"
          
          # Trigger the release workflow
          if gh workflow run release.yml \
            --field version="$NEW_VERSION" \
            --field target_branch="$TARGET_BRANCH" \
            --ref "$TARGET_BRANCH"; then
            echo "âœ… Release workflow triggered successfully" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "âŒ Error: Failed to trigger release workflow" >&2
            echo "âŒ **Error:** Failed to trigger release workflow" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Output workflow run information
        shell: bash
        run: |
          set -e
          
          TARGET_BRANCH="${{ inputs.target_branch }}"
          REPO_URL="https://github.com/${{ github.repository }}"
          ACTIONS_URL="$REPO_URL/actions"
          
          cat >> "$GITHUB_STEP_SUMMARY" << EOF
          
          ## ðŸ“‹ Next Steps
          
          ðŸŽ‰ **Release workflow triggered for version v$NEW_VERSION on branch \`$TARGET_BRANCH\`**
          
          ðŸ“Š **Monitor Progress:**
          - [View Actions Page]($ACTIONS_URL)
          - [View Releases Page]($REPO_URL/releases)
          
          â³ **What happens next:**
          1. The release workflow will create tag \`v$NEW_VERSION\`
          2. A GitHub release will be published
          3. Release artifacts will be generated
          
          ðŸ”— **Useful Links:**
          - [Repository]($REPO_URL)
          - [Tags]($REPO_URL/tags)
          
          EOF
          
          echo "Release workflow triggered for version v$NEW_VERSION on branch $TARGET_BRANCH. Monitor progress at $ACTIONS_URL"